<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pynkowski.theory API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pynkowski.theory</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import scipy.stats

norm = scipy.stats.norm()


def get_μ(cls):
    &#34;&#34;&#34;Compute the first derivative of the covariance function at the origin for a Gaussian field 
    defined on the sphere with angular power spectrum &#39;cls&#39;.

    Parameters
    ----------
    cls : np.array
        The angular power spectrum of the Gaussian field.
    
    Returns
    -------
    μ : float
        The first derivative of the covariance function of a field at the origin.
    
    &#34;&#34;&#34;
    cls = np.array(cls, dtype=float)
    ℓ = np.arange(cls.shape[0])
    cls /= np.sum(cls * (2.*ℓ+1.) / (4.*np.pi))
    μ = np.sum(cls * (2.*ℓ+1.) * ℓ*(ℓ+1.) / (8.*np.pi))
    return μ

def V0_th_s0(u):
    &#34;&#34;&#34;Compute the expected value of the normalised first MF v0 at threshold u for a Gaussian isotropic scalar field normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the first MF is computed.
    
    Returns
    -------
    v0 : np.array
        The expected value of the normalised first MF at thresholds u.
    
    &#34;&#34;&#34;    
    return (1-norm.cdf(u))

def V0_th_P2(u):
    &#34;&#34;&#34;Compute the expected value of the normalised first MF v0 at threshold u for the sum of two squared Gaussian isotropic fields normalised for their standard deviations.

    Parameters
    ----------
    u : np.array
        Thresholds at which the first MF is computed.
    
    Returns
    -------
    v0 : np.array
        The expected value of the normalised first MF at thresholds u.
    
    &#34;&#34;&#34;    
    return 1-((1-np.exp(-u/2.)) * (u&gt;=0.))

def V0_th_s2(u):
    &#34;&#34;&#34;Compute the expected value of the normalised first MF v0 at threshold u for a Gaussian field defined in SO(3) normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the first MF is computed.
    
    Returns
    -------
    v0 : np.array
        The expected value of the normalised first MF at thresholds u.
    
    &#34;&#34;&#34;    
    return (1-norm.cdf(u))

def V1_th_s0(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised second MF v1 at threshold u for a Gaussian isotropic scalar field normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the second MF is computed.
        
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v1 : np.array
        The expected value of the normalised second MF at thresholds u.
    
    &#34;&#34;&#34;    
    return np.sqrt(μ) * np.exp(-u**2./2.) / 8.

def V1_th_P2(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised second MF v1 at threshold u for the sum of two squared Gaussian isotropic fields normalised for their standard deviations.

    Parameters
    ----------
    u : np.array
        Thresholds at which the second MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v1 : np.array
        The expected value of the normalised second MF at thresholds u.
    
    &#34;&#34;&#34;    
    return np.sqrt(μ * (u) / 4.) * np.exp(-u/2.) * (u&gt;=0.) * (np.sqrt(np.pi/8.))

def V1_th_s2(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised second MF v1 at thresholds u for a Gaussian field defined in SO(3) normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the second MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v1 : np.array
        The expected value of the normalised second MF at thresholds u.
    
    &#34;&#34;&#34;    
    return 2.*np.sqrt(2*np.pi**3 *μ) * norm.pdf(u) / (4*np.pi**2)
    
def V2_th_s0(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised third MF v2 at threshold u for a Gaussian isotropic scalar field normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the third MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v2 : np.array
        The expected value of the normalised third MF at thresholds u.
    
    &#34;&#34;&#34;    
    return μ * u * np.exp(-u**2. /2.) / np.sqrt(2.*np.pi)**3. 
    
def V2_th_P2(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised third MF v2 at threshold u for the sum of two squared Gaussian isotropic fields normalised for their standard deviations.

    Parameters
    ----------
    u : np.array
        Thresholds at which the third MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v2 : np.array
        The expected value of the normalised third MF at thresholds u.
    
    &#34;&#34;&#34;    
    return (((μ * (u-1.) * np.exp(-u/2.)) / (2.*np.pi) ) * (u&gt;=0.)) 
    
def V2_th_s2(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised third MF v2 at threshold u for a Gaussian field defined in SO(3) normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Thresholds at which the third MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v2 : np.array
        The expected value of the normalised third MF at thresholds u.
    
    &#34;&#34;&#34;    
    return (((1-norm.cdf(u)) * 3.*np.pi + u*norm.pdf(u) * μ * 4.*np.pi) / (4*np.pi**2)) / (6.*np.pi)   #This has a ratio of ~0.13

def V3_th_s2(u, μ):
    &#34;&#34;&#34;Compute the expected value of the normalised fourth MF v3 at threshold u for a Gaussian field defined in SO(3) normalised for its standard deviation.

    Parameters
    ----------
    u : np.array
        Threshold at which the fourth MF is computed.
    
    μ : float
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
    
    Returns
    -------
    v3 : np.array
        The expected value of the normalised fourth MF at threshold u.
    
    &#34;&#34;&#34;    
    return μ*np.exp(-u**2. /2.) * (u**2. -1.) / 8
    
def define_mu(cls,μ):
    &#34;&#34;&#34;Return the first derivative of the covariance function at the origin for a field 
    computed accordingly to which input variable is given.

    Parameters
    ----------
    cls : np.array, optional
        The angular power spectrum of the field.
        Default : None

    μ : scalar, optional
        The first derivative of the covariance function at the origin for the field. If None, μ=1 is assumed.
        Default : None

    Returns
    -------
    μ : scalar
        The first derivative of the covariance function of the field at the origin.

    Notes
    -----
    The derivatives are always computed full-sky regardless of input mask.
    
    &#34;&#34;&#34;
    if (cls is not None) and (μ is not None):
        raise ValueError(r&#34;Both cls and $\mu$ cannot be given&#34;)
    if (cls is not None) and (μ is None):
        return get_μ(cls)
    if (cls is None) and (μ is not None):
        return μ
    if (cls is None) and (μ is None):
        return 1.
    
def define_us_for_V(us,dus,iters=1000):
    &#34;&#34;&#34;Return the thresholds where MFs (except for v0) are computed before averaging within the bins &#39;dus&#39;.

    Parameters
    ----------
    us : np.array
        The thresholds at which MFs have to be computed.

    dus : np.array
        The width of the bins associated to the thresholds &#39;us&#39;.
        
    iters : int, optional
        the number of thresholds to consider within each bin.

    Returns
    -------
    us_ : np.array
        The sequence of thresholds where MFs are computed before averaging within each bin, with shape (us.shape, iters)
        
    iters : int, optional
        the number of thresholds considered within each bin.
    
    &#34;&#34;&#34;
    return np.vstack([np.linspace(u-du/2, u+du/2, iters) for u, du in zip(us, dus)])








class TheoryTemperature():
    &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field normalised for its standard deviation defined on the sphere 
    like the temperature anisotropies of the CMB.

    Parameters
    ----------
    us : np.array, optional
        The thresholds at which the theoretical MFs will be computed. 
        If not given, a range between -5σ and 5σ with steps of 0.1σ is considered, 
        with σ=1 the expected standard deviation of the field.
    
    cls : np.array, optional
        The angular power spectrum of the Gaussian isotropic scalar field. 
        Default : None 
    
    μ : float, scalar, optional
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
        If both μ and cls are given, an error will be raised.
        If only cls is given, μ will be computed from input cls.
        If neither μ nor cls are given, μ is assumed to be 1.
        Default : None
        
    average_bin : bool, optional
        If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
        If False, the results are the evaluation on the center of each bin.
        The value is always exactly computed for V0, as the computation on maps does not imply binning.
        Defaul : True
        
    edges : bool, optional
        If False, the given &#39;us&#39; is considered as an array of uniformly distributed thresholds. 
        If True, input &#39;us&#39; is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds. 
        In this last case, the thresholds are the central value of the given bins.
        Neglected if &#39;us&#39; is not given.
        Default : False.

    Attributes
    ----------
    us : np.array
        The thresholds at which the theoretical MFs are computed. 
        
    μ : float, scalar
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
        
    &#34;&#34;&#34;    
    def __init__(self, us=None, cls=None, μ=None, average_bin=True, edges=False):
        &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.

        &#34;&#34;&#34;    
        if (us is None):
            Δu = 0.1
            self.us = np.arange(-5+Δu/2., 5.+Δu/2., Δu)
            self.dus = Δu*np.ones(self.us.shape[0])
        else:
            us = np.array(us)
            if us.shape == (1,):
                self.us = us
                self.dus = 0.
            else:
                if edges:
                    self.dus = (us[1:]-us[:-1])
                    self.us = (us[1:]+us[:-1])/2.
                else:
                    self.us = us
                    self.dus = (us[1]-us[0])*np.ones(us.shape[0])

             
        self.μ = define_mu(cls,μ)   
        if not average_bin:
            self.dus = 0.*self.dus
        
    
    def V0(self):
        &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

        &#34;&#34;&#34;    
        return (V0_th_s0(self.us))

    def V1(self):
        &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

        &#34;&#34;&#34; 
        us_ = define_us_for_V(self.us,self.dus)
        v1_ = V1_th_s0(us_, self.μ)
        
        return np.mean(v1_, axis=1)

    def V2(self):
        &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

        &#34;&#34;&#34;    
        us_ = define_us_for_V(self.us,self.dus)
        v2_ = V2_th_s0(us_, self.μ)
        
        return np.mean(v2_, axis=1)



class TheoryP2():
    &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for the sum of two squared Gaussian isotropic fields normalised for their standard deviations defined on the sphere 
    like the polarised intensity of the CMB (P^2 = Q^2 + U^2).

    Parameters
    ----------
    us : np.array, optional
        The thresholds at which the theoretical MFs will be computed. 
        If not given, a range between 0 and 5σ with steps of 0.1σ is considered, 
        with σ=1 the expected standard deviation of the fields U and Q.
    
    cls : np.array, optional
        The angular power spectrum associated to the Gaussian isotropic fields. 
        Shape &#39;(..., lmax+1)&#39;. &#39;...&#39; can be 2 (EE, BB) or absent (assumed to be EE+BB).
        Default : None 
    
    μ : float, scalar, optional
        The derivative of the covariance function at the origin for each of the two independent Gaussian isotropic fields (i.e., U and Q in the cosmological case).
        If both μ and cls are given, an error will be raised.
        If only cls is given, μ will be computed from input cls.
        If neither μ nor cls are given, μ is assumed to be 1.
        Default : None
        
    average_bin : bool, optional
        If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
        If False, the results are the evaluation on the center of each bin.
        The value is always exactly computed for V0, as the computation on maps does not imply binning.
        Defaul : True
        
    edges : bool, optional
        If False, the given &#39;us&#39; is considered as an array of uniformly distributed thresholds. 
        If True, input &#39;us&#39; is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds. 
        In this last case, the thresholds are the central value of the given bins.
        Neglected if &#39;us&#39; is not given.
        Default : False.

    Attributes
    ----------
    us : np.array
        The thresholds at which the theoretical MFs are computed. 
        
    μ : float, scalar
        The derivative of the covariance function at the origin for the sum of two squared Gaussian isotropic fields.
        
    &#34;&#34;&#34;    
    def __init__(self, us=None, Cls=None, μ=None, average_bin=True, edges=False):
        &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.

        &#34;&#34;&#34;    
        if (us is None):
            Δu = 0.05
            self.us = np.arange(Δu/2., 5.+Δu/2., Δu)
            self.dus = Δu*np.ones(self.us.shape[0])
        else:
            us = np.array(us)
            if us.shape == (1,):
                self.us = us
                self.dus = 0.
            else:
                if edges:
                    self.dus = (us[1:]-us[:-1])
                    self.us = (us[1:]+us[:-1])/2.
                else:
                    self.us = us
                    self.dus = (us[1]-us[0])*np.ones(us.shape[0])

        if (Cls is not None) and (μ is None):
            if (Cls.ndim == 2) and (Cls.shape[0]==2):
                cls = (cls[0]+cls[1])/2.
            elif (Cls.ndim == 1):
                cls = cls/2.
            else:
                raise ValueError(r&#34;Cls dimension has to be either (2,lmax+1) or (lmax+1)&#34;)
                
        self.μ = define_mu(Cls,μ)   
        if not average_bin:
            self.dus = 0.*self.dus
        
    
    def V0(self):
        &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

        &#34;&#34;&#34;    
        return (V0_th_P2(self.us))

    def V1(self):
        &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

        &#34;&#34;&#34; 
        us_ = define_us_for_V(self.us,self.dus)
        v1_ = V1_th_P2(us_, self.μ)
        
        return np.mean(v1_, axis=1)
    
    def V2(self):
        &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

        &#34;&#34;&#34;    
        us_ = define_us_for_V(self.us,self.dus)
        v2_ = V2_th_P2(us_, self.μ)
        
        return np.mean(v2_, axis=1)




__all__ = [&#34;TheoryP2&#34;,
           &#34;TheoryTemperature&#34;,
           &#34;get_μ&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pynkowski.theory.get_μ"><code class="name flex">
<span>def <span class="ident">get_μ</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the first derivative of the covariance function at the origin for a Gaussian field
defined on the sphere with angular power spectrum 'cls'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The angular power spectrum of the Gaussian field.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>μ</code></strong> :&ensp;<code>float</code></dt>
<dd>The first derivative of the covariance function of a field at the origin.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_μ(cls):
    &#34;&#34;&#34;Compute the first derivative of the covariance function at the origin for a Gaussian field 
    defined on the sphere with angular power spectrum &#39;cls&#39;.

    Parameters
    ----------
    cls : np.array
        The angular power spectrum of the Gaussian field.
    
    Returns
    -------
    μ : float
        The first derivative of the covariance function of a field at the origin.
    
    &#34;&#34;&#34;
    cls = np.array(cls, dtype=float)
    ℓ = np.arange(cls.shape[0])
    cls /= np.sum(cls * (2.*ℓ+1.) / (4.*np.pi))
    μ = np.sum(cls * (2.*ℓ+1.) * ℓ*(ℓ+1.) / (8.*np.pi))
    return μ</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pynkowski.theory.TheoryP2"><code class="flex name class">
<span>class <span class="ident">TheoryP2</span></span>
<span>(</span><span>us=None, Cls=None, μ=None, average_bin=True, edges=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to compute the expected values of Minkowski functionals (MFs) for the sum of two squared Gaussian isotropic fields normalised for their standard deviations defined on the sphere
like the polarised intensity of the CMB (P^2 = Q^2 + U^2).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>us</code></strong> :&ensp;<code>np.array</code>, optional</dt>
<dd>The thresholds at which the theoretical MFs will be computed.
If not given, a range between 0 and 5σ with steps of 0.1σ is considered,
with σ=1 the expected standard deviation of the fields U and Q.</dd>
<dt><strong><code>cls</code></strong> :&ensp;<code>np.array</code>, optional</dt>
<dd>The angular power spectrum associated to the Gaussian isotropic fields.
Shape '(&hellip;, lmax+1)'. '&hellip;' can be 2 (EE, BB) or absent (assumed to be EE+BB).
Default : None</dd>
<dt><strong><code>μ</code></strong> :&ensp;<code>float, scalar</code>, optional</dt>
<dd>The derivative of the covariance function at the origin for each of the two independent Gaussian isotropic fields (i.e., U and Q in the cosmological case).
If both μ and cls are given, an error will be raised.
If only cls is given, μ will be computed from input cls.
If neither μ nor cls are given, μ is assumed to be 1.
Default : None</dd>
<dt><strong><code>average_bin</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
If False, the results are the evaluation on the center of each bin.
The value is always exactly computed for V0, as the computation on maps does not imply binning.
Defaul : True</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False, the given 'us' is considered as an array of uniformly distributed thresholds.
If True, input 'us' is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds.
In this last case, the thresholds are the central value of the given bins.
Neglected if 'us' is not given.
Default : False.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>us</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The thresholds at which the theoretical MFs are computed.</dd>
<dt><strong><code>μ</code></strong> :&ensp;<code>float, scalar</code></dt>
<dd>The derivative of the covariance function at the origin for the sum of two squared Gaussian isotropic fields.</dd>
</dl>
<p>Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryP2():
    &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for the sum of two squared Gaussian isotropic fields normalised for their standard deviations defined on the sphere 
    like the polarised intensity of the CMB (P^2 = Q^2 + U^2).

    Parameters
    ----------
    us : np.array, optional
        The thresholds at which the theoretical MFs will be computed. 
        If not given, a range between 0 and 5σ with steps of 0.1σ is considered, 
        with σ=1 the expected standard deviation of the fields U and Q.
    
    cls : np.array, optional
        The angular power spectrum associated to the Gaussian isotropic fields. 
        Shape &#39;(..., lmax+1)&#39;. &#39;...&#39; can be 2 (EE, BB) or absent (assumed to be EE+BB).
        Default : None 
    
    μ : float, scalar, optional
        The derivative of the covariance function at the origin for each of the two independent Gaussian isotropic fields (i.e., U and Q in the cosmological case).
        If both μ and cls are given, an error will be raised.
        If only cls is given, μ will be computed from input cls.
        If neither μ nor cls are given, μ is assumed to be 1.
        Default : None
        
    average_bin : bool, optional
        If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
        If False, the results are the evaluation on the center of each bin.
        The value is always exactly computed for V0, as the computation on maps does not imply binning.
        Defaul : True
        
    edges : bool, optional
        If False, the given &#39;us&#39; is considered as an array of uniformly distributed thresholds. 
        If True, input &#39;us&#39; is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds. 
        In this last case, the thresholds are the central value of the given bins.
        Neglected if &#39;us&#39; is not given.
        Default : False.

    Attributes
    ----------
    us : np.array
        The thresholds at which the theoretical MFs are computed. 
        
    μ : float, scalar
        The derivative of the covariance function at the origin for the sum of two squared Gaussian isotropic fields.
        
    &#34;&#34;&#34;    
    def __init__(self, us=None, Cls=None, μ=None, average_bin=True, edges=False):
        &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.

        &#34;&#34;&#34;    
        if (us is None):
            Δu = 0.05
            self.us = np.arange(Δu/2., 5.+Δu/2., Δu)
            self.dus = Δu*np.ones(self.us.shape[0])
        else:
            us = np.array(us)
            if us.shape == (1,):
                self.us = us
                self.dus = 0.
            else:
                if edges:
                    self.dus = (us[1:]-us[:-1])
                    self.us = (us[1:]+us[:-1])/2.
                else:
                    self.us = us
                    self.dus = (us[1]-us[0])*np.ones(us.shape[0])

        if (Cls is not None) and (μ is None):
            if (Cls.ndim == 2) and (Cls.shape[0]==2):
                cls = (cls[0]+cls[1])/2.
            elif (Cls.ndim == 1):
                cls = cls/2.
            else:
                raise ValueError(r&#34;Cls dimension has to be either (2,lmax+1) or (lmax+1)&#34;)
                
        self.μ = define_mu(Cls,μ)   
        if not average_bin:
            self.dus = 0.*self.dus
        
    
    def V0(self):
        &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

        &#34;&#34;&#34;    
        return (V0_th_P2(self.us))

    def V1(self):
        &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

        &#34;&#34;&#34; 
        us_ = define_us_for_V(self.us,self.dus)
        v1_ = V1_th_P2(us_, self.μ)
        
        return np.mean(v1_, axis=1)
    
    def V2(self):
        &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

        &#34;&#34;&#34;    
        us_ = define_us_for_V(self.us,self.dus)
        v2_ = V2_th_P2(us_, self.μ)
        
        return np.mean(v2_, axis=1)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pynkowski.theory.TheoryP2.V0"><code class="name flex">
<span>def <span class="ident">V0</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised first MF v0 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V0(self):
    &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

    &#34;&#34;&#34;    
    return (V0_th_P2(self.us))</code></pre>
</details>
</dd>
<dt id="pynkowski.theory.TheoryP2.V1"><code class="name flex">
<span>def <span class="ident">V1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised second MF v1 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V1(self):
    &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

    &#34;&#34;&#34; 
    us_ = define_us_for_V(self.us,self.dus)
    v1_ = V1_th_P2(us_, self.μ)
    
    return np.mean(v1_, axis=1)</code></pre>
</details>
</dd>
<dt id="pynkowski.theory.TheoryP2.V2"><code class="name flex">
<span>def <span class="ident">V2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised third MF v2 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V2(self):
    &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

    &#34;&#34;&#34;    
    us_ = define_us_for_V(self.us,self.dus)
    v2_ = V2_th_P2(us_, self.μ)
    
    return np.mean(v2_, axis=1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pynkowski.theory.TheoryTemperature"><code class="flex name class">
<span>class <span class="ident">TheoryTemperature</span></span>
<span>(</span><span>us=None, cls=None, μ=None, average_bin=True, edges=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field normalised for its standard deviation defined on the sphere
like the temperature anisotropies of the CMB.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>us</code></strong> :&ensp;<code>np.array</code>, optional</dt>
<dd>The thresholds at which the theoretical MFs will be computed.
If not given, a range between -5σ and 5σ with steps of 0.1σ is considered,
with σ=1 the expected standard deviation of the field.</dd>
<dt><strong><code>cls</code></strong> :&ensp;<code>np.array</code>, optional</dt>
<dd>The angular power spectrum of the Gaussian isotropic scalar field.
Default : None</dd>
<dt><strong><code>μ</code></strong> :&ensp;<code>float, scalar</code>, optional</dt>
<dd>The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
If both μ and cls are given, an error will be raised.
If only cls is given, μ will be computed from input cls.
If neither μ nor cls are given, μ is assumed to be 1.
Default : None</dd>
<dt><strong><code>average_bin</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
If False, the results are the evaluation on the center of each bin.
The value is always exactly computed for V0, as the computation on maps does not imply binning.
Defaul : True</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False, the given 'us' is considered as an array of uniformly distributed thresholds.
If True, input 'us' is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds.
In this last case, the thresholds are the central value of the given bins.
Neglected if 'us' is not given.
Default : False.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>us</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The thresholds at which the theoretical MFs are computed.</dd>
<dt><strong><code>μ</code></strong> :&ensp;<code>float, scalar</code></dt>
<dd>The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.</dd>
</dl>
<p>Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryTemperature():
    &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field normalised for its standard deviation defined on the sphere 
    like the temperature anisotropies of the CMB.

    Parameters
    ----------
    us : np.array, optional
        The thresholds at which the theoretical MFs will be computed. 
        If not given, a range between -5σ and 5σ with steps of 0.1σ is considered, 
        with σ=1 the expected standard deviation of the field.
    
    cls : np.array, optional
        The angular power spectrum of the Gaussian isotropic scalar field. 
        Default : None 
    
    μ : float, scalar, optional
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
        If both μ and cls are given, an error will be raised.
        If only cls is given, μ will be computed from input cls.
        If neither μ nor cls are given, μ is assumed to be 1.
        Default : None
        
    average_bin : bool, optional
        If True, the results of V1 and V2 are the average on each bin, to be compared with binned computations on maps.
        If False, the results are the evaluation on the center of each bin.
        The value is always exactly computed for V0, as the computation on maps does not imply binning.
        Defaul : True
        
    edges : bool, optional
        If False, the given &#39;us&#39; is considered as an array of uniformly distributed thresholds. 
        If True, input &#39;us&#39; is considered as a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform distributions of thresholds. 
        In this last case, the thresholds are the central value of the given bins.
        Neglected if &#39;us&#39; is not given.
        Default : False.

    Attributes
    ----------
    us : np.array
        The thresholds at which the theoretical MFs are computed. 
        
    μ : float, scalar
        The derivative of the covariance function at the origin for the Gaussian isotropic scalar field.
        
    &#34;&#34;&#34;    
    def __init__(self, us=None, cls=None, μ=None, average_bin=True, edges=False):
        &#34;&#34;&#34;Class to compute the expected values of Minkowski functionals (MFs) for a Gaussian isotropic scalar field defined on the sphere.

        &#34;&#34;&#34;    
        if (us is None):
            Δu = 0.1
            self.us = np.arange(-5+Δu/2., 5.+Δu/2., Δu)
            self.dus = Δu*np.ones(self.us.shape[0])
        else:
            us = np.array(us)
            if us.shape == (1,):
                self.us = us
                self.dus = 0.
            else:
                if edges:
                    self.dus = (us[1:]-us[:-1])
                    self.us = (us[1:]+us[:-1])/2.
                else:
                    self.us = us
                    self.dus = (us[1]-us[0])*np.ones(us.shape[0])

             
        self.μ = define_mu(cls,μ)   
        if not average_bin:
            self.dus = 0.*self.dus
        
    
    def V0(self):
        &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

        &#34;&#34;&#34;    
        return (V0_th_s0(self.us))

    def V1(self):
        &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

        &#34;&#34;&#34; 
        us_ = define_us_for_V(self.us,self.dus)
        v1_ = V1_th_s0(us_, self.μ)
        
        return np.mean(v1_, axis=1)

    def V2(self):
        &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

        &#34;&#34;&#34;    
        us_ = define_us_for_V(self.us,self.dus)
        v2_ = V2_th_s0(us_, self.μ)
        
        return np.mean(v2_, axis=1)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pynkowski.theory.TheoryTemperature.V0"><code class="name flex">
<span>def <span class="ident">V0</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised first MF v0 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V0(self):
    &#34;&#34;&#34;Compute the expected values of the normalised first MF v0 at the different thresholds us.

    &#34;&#34;&#34;    
    return (V0_th_s0(self.us))</code></pre>
</details>
</dd>
<dt id="pynkowski.theory.TheoryTemperature.V1"><code class="name flex">
<span>def <span class="ident">V1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised second MF v1 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V1(self):
    &#34;&#34;&#34;Compute the expected values of the normalised second MF v1 at the different thresholds us.

    &#34;&#34;&#34; 
    us_ = define_us_for_V(self.us,self.dus)
    v1_ = V1_th_s0(us_, self.μ)
    
    return np.mean(v1_, axis=1)</code></pre>
</details>
</dd>
<dt id="pynkowski.theory.TheoryTemperature.V2"><code class="name flex">
<span>def <span class="ident">V2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the expected values of the normalised third MF v2 at the different thresholds us.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def V2(self):
    &#34;&#34;&#34;Compute the expected values of the normalised third MF v2 at the different thresholds us.

    &#34;&#34;&#34;    
    us_ = define_us_for_V(self.us,self.dus)
    v2_ = V2_th_s0(us_, self.μ)
    
    return np.mean(v2_, axis=1)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pynkowski" href="index.html">pynkowski</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pynkowski.theory.get_μ" href="#pynkowski.theory.get_μ">get_μ</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pynkowski.theory.TheoryP2" href="#pynkowski.theory.TheoryP2">TheoryP2</a></code></h4>
<ul class="">
<li><code><a title="pynkowski.theory.TheoryP2.V0" href="#pynkowski.theory.TheoryP2.V0">V0</a></code></li>
<li><code><a title="pynkowski.theory.TheoryP2.V1" href="#pynkowski.theory.TheoryP2.V1">V1</a></code></li>
<li><code><a title="pynkowski.theory.TheoryP2.V2" href="#pynkowski.theory.TheoryP2.V2">V2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynkowski.theory.TheoryTemperature" href="#pynkowski.theory.TheoryTemperature">TheoryTemperature</a></code></h4>
<ul class="">
<li><code><a title="pynkowski.theory.TheoryTemperature.V0" href="#pynkowski.theory.TheoryTemperature.V0">V0</a></code></li>
<li><code><a title="pynkowski.theory.TheoryTemperature.V1" href="#pynkowski.theory.TheoryTemperature.V1">V1</a></code></li>
<li><code><a title="pynkowski.theory.TheoryTemperature.V2" href="#pynkowski.theory.TheoryTemperature.V2">V2</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>